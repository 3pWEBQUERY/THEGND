// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

// Job categories available for posting
enum JobCategory {
  ESCORT
  CLEANING
  SECURITY
  HOUSEKEEPING
}

// Rental categories available for posting
enum RentalCategory {
  APARTMENT
  ROOM
  STUDIO
  EVENT_SPACE
}

// Jobs posted by Agencies, Clubs, and Studios
model Job {
  id            String      @id @default(cuid())
  title         String
  shortDesc     String      // short description
  description   String      // full description
  category      JobCategory
  location      String?
  city          String?
  country       String?
  salaryInfo    String?     // free text
  contactInfo   String?     // email/phone/url
  media         String?     // JSON array of media URLs
  isActive      Boolean     @default(true)
  postedById    String
  postedBy      User        @relation(fields: [postedById], references: [id], onDelete: Cascade)
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  @@index([category, createdAt])
  @@index([postedById, createdAt])
  @@map("jobs")
}

// Rentals posted by Agencies, Clubs, and Studios
model Rental {
  id            String          @id @default(cuid())
  title         String
  shortDesc     String
  description   String
  category      RentalCategory
  location      String?
  city          String?
  country       String?
  priceInfo     String?
  contactInfo   String?
  media         String?
  isActive      Boolean         @default(true)
  postedById    String
  postedBy      User            @relation(fields: [postedById], references: [id], onDelete: Cascade)
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt

  @@index([category, createdAt])
  @@index([postedById, createdAt])
  @@map("rentals")
}

// ─── Reddit-style Communities ─────────────────────────────────────────────

enum CommunityType {
  PUBLIC      // anyone can view and post
  RESTRICTED  // anyone can view, only members can post
  PRIVATE     // only members can view and post
}

enum CommunityMemberRole {
  OWNER
  MODERATOR
  MEMBER
}

enum CommunityPostType {
  TEXT
  LINK
  IMAGE
  POLL
  VIDEO
}

enum VoteType {
  UP
  DOWN
}

enum BanStatus {
  TEMPORARY
  PERMANENT
}

enum ModActionType {
  PIN_POST
  UNPIN_POST
  REMOVE_POST
  RESTORE_POST
  LOCK_POST
  UNLOCK_POST
  BAN_USER
  UNBAN_USER
  CHANGE_ROLE
  EDIT_RULES
  EDIT_SETTINGS
  REMOVE_COMMENT
  RESTORE_COMMENT
  APPROVE_POST
}

model Community {
  id          String         @id @default(cuid())
  name        String
  slug        String         @unique
  description String?
  sidebar     String?        // markdown sidebar content
  icon        String?        // community avatar URL
  banner      String?        // header banner URL
  color       String?        // accent color hex
  type        CommunityType  @default(PUBLIC)
  isNSFW      Boolean        @default(false)
  isArchived  Boolean        @default(false)
  memberCount Int            @default(1) // cached counter
  creatorId   String
  creator     User           @relation("CommunityCreator", fields: [creatorId], references: [id], onDelete: Cascade)
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  members     CommunityMember[]
  posts       CommunityPost[]
  rules       CommunityRule[]
  flairs      CommunityFlair[]
  bans        CommunityBan[]
  modLog      CommunityModLog[]

  @@index([creatorId])
  @@index([memberCount(sort: Desc)])
  @@index([type, isArchived])
  @@map("communities")
}

model CommunityMember {
  id          String               @id @default(cuid())
  communityId String
  community   Community            @relation(fields: [communityId], references: [id], onDelete: Cascade)
  userId      String
  user        User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  role        CommunityMemberRole  @default(MEMBER)
  joinedAt    DateTime             @default(now())

  @@unique([communityId, userId])
  @@index([userId])
  @@map("community_members")
}

model CommunityRule {
  id          String    @id @default(cuid())
  communityId String
  community   Community @relation(fields: [communityId], references: [id], onDelete: Cascade)
  title       String
  description String?
  sortOrder   Int       @default(0)
  createdAt   DateTime  @default(now())

  @@index([communityId, sortOrder])
  @@map("community_rules")
}

model CommunityFlair {
  id          String    @id @default(cuid())
  communityId String
  community   Community @relation(fields: [communityId], references: [id], onDelete: Cascade)
  name        String
  color       String    @default("#6B7280") // gray-500
  textColor   String    @default("#FFFFFF")
  createdAt   DateTime  @default(now())

  posts       CommunityPost[]

  @@index([communityId])
  @@map("community_flairs")
}

model CommunityPost {
  id               String            @id @default(cuid())
  communityId      String
  community        Community         @relation(fields: [communityId], references: [id], onDelete: Cascade)
  authorId         String
  author           User              @relation(fields: [authorId], references: [id], onDelete: Cascade)
  title            String
  content          String?           // markdown for TEXT posts
  linkUrl          String?           // for LINK posts
  linkPreviewTitle String?
  linkPreviewImage String?
  images           String?           // JSON array of URLs for IMAGE posts
  videoUrl         String?           // for VIDEO posts
  type             CommunityPostType @default(TEXT)
  flairId          String?
  flair            CommunityFlair?   @relation(fields: [flairId], references: [id], onDelete: SetNull)
  isPinned         Boolean           @default(false)
  isLocked         Boolean           @default(false)
  isRemoved        Boolean           @default(false) // mod soft-delete
  isDeleted        Boolean           @default(false) // author soft-delete
  score            Int               @default(0)     // cached upvotes - downvotes
  commentCount     Int               @default(0)     // cached
  viewCount        Int               @default(0)
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt

  votes            Vote[]            @relation("PostVotes")
  comments         CommunityComment[]
  pollOptions      PollOption[]
  savedBy          SavedPost[]
  reports          CommunityReport[] @relation("ReportedPost")

  @@index([communityId, isPinned, createdAt(sort: Desc)])
  @@index([communityId, score(sort: Desc)])
  @@index([authorId, createdAt(sort: Desc)])
  @@index([isRemoved, isDeleted])
  @@map("community_posts")
}

model CommunityComment {
  id        String    @id @default(cuid())
  postId    String
  post      CommunityPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  authorId  String
  author    User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  parentId  String?
  parent    CommunityComment? @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  children  CommunityComment[] @relation("CommentReplies")
  content   String    // markdown
  type      String    @default("TEXT") // TEXT, LINK, IMAGE, VIDEO
  linkUrl   String?
  images    String?   // JSON array of URLs
  videoUrl  String?
  score     Int       @default(0) // cached
  isRemoved Boolean   @default(false)
  isDeleted Boolean   @default(false)
  editedAt  DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  votes     Vote[]    @relation("CommentVotes")
  reports   CommunityReport[] @relation("ReportedComment")

  @@index([postId, parentId, createdAt])
  @@index([authorId, createdAt(sort: Desc)])
  @@map("community_comments")
}

model Vote {
  id        String    @id @default(cuid())
  userId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  postId    String?
  post      CommunityPost? @relation("PostVotes", fields: [postId], references: [id], onDelete: Cascade)
  commentId String?
  comment   CommunityComment? @relation("CommentVotes", fields: [commentId], references: [id], onDelete: Cascade)
  type      VoteType
  createdAt DateTime  @default(now())

  @@unique([userId, postId])
  @@unique([userId, commentId])
  @@index([postId, type])
  @@index([commentId, type])
  @@map("community_votes")
}

model PollOption {
  id        String    @id @default(cuid())
  postId    String
  post      CommunityPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  text      String
  sortOrder Int       @default(0)
  createdAt DateTime  @default(now())

  votes     PollVote[]

  @@index([postId, sortOrder])
  @@map("community_poll_options")
}

model PollVote {
  id        String     @id @default(cuid())
  optionId  String
  option    PollOption @relation(fields: [optionId], references: [id], onDelete: Cascade)
  userId    String
  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime   @default(now())

  @@unique([optionId, userId])
  @@index([userId])
  @@map("community_poll_votes")
}

model CommunityBan {
  id          String    @id @default(cuid())
  communityId String
  community   Community @relation(fields: [communityId], references: [id], onDelete: Cascade)
  userId      String
  user        User      @relation("BannedUser", fields: [userId], references: [id], onDelete: Cascade)
  bannedById  String
  bannedBy    User      @relation("BanIssuedBy", fields: [bannedById], references: [id], onDelete: Cascade)
  reason      String?
  status      BanStatus @default(PERMANENT)
  expiresAt   DateTime?
  createdAt   DateTime  @default(now())

  @@unique([communityId, userId])
  @@index([communityId, userId])
  @@map("community_bans")
}

model CommunityModLog {
  id              String        @id @default(cuid())
  communityId     String
  community       Community     @relation(fields: [communityId], references: [id], onDelete: Cascade)
  moderatorId     String
  moderator       User          @relation("ModLogModerator", fields: [moderatorId], references: [id], onDelete: Cascade)
  action          ModActionType
  targetUserId    String?
  targetUser      User?         @relation("ModLogTarget", fields: [targetUserId], references: [id], onDelete: SetNull)
  targetPostId    String?
  targetCommentId String?
  reason          String?
  metadata        String?       // JSON
  createdAt       DateTime      @default(now())

  @@index([communityId, createdAt(sort: Desc)])
  @@map("community_mod_log")
}

model CommunityReport {
  id          String     @id @default(cuid())
  communityId String
  reporterId  String
  reporter    User       @relation("CommunityReporter", fields: [reporterId], references: [id], onDelete: Cascade)
  postId      String?
  post        CommunityPost? @relation("ReportedPost", fields: [postId], references: [id], onDelete: Cascade)
  commentId   String?
  comment     CommunityComment? @relation("ReportedComment", fields: [commentId], references: [id], onDelete: Cascade)
  reason      String
  ruleId      String?    // optional reference to community rule
  status      String     @default("OPEN") // OPEN, RESOLVED, DISMISSED
  resolvedById String?
  resolvedBy  User?      @relation("ReportResolver", fields: [resolvedById], references: [id], onDelete: SetNull)
  resolvedAt  DateTime?
  createdAt   DateTime   @default(now())

  @@index([communityId, status])
  @@index([postId])
  @@index([commentId])
  @@map("community_reports")
}

model SavedPost {
  id        String        @id @default(cuid())
  userId    String
  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  postId    String
  post      CommunityPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  createdAt DateTime      @default(now())

  @@unique([userId, postId])
  @@index([userId, createdAt(sort: Desc)])
  @@map("community_saved_posts")
}

// Legacy: keep old tables for migration period (will be removed later)

enum GroupPrivacy {
  PUBLIC
  PRIVATE
}

enum GroupRole {
  ADMIN
  MEMBER
}

model FeedGroup {
  id          String       @id @default(cuid())
  name        String
  slug        String       @unique
  description String?
  cover       String?
  privacy     GroupPrivacy @default(PUBLIC)
  ownerId     String
  owner       User         @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  // Relations
  members     FeedGroupMember[]
  posts       Post[]

  @@index([ownerId])
  @@map("feed_groups")
}

model FeedGroupMember {
  id        String     @id @default(cuid())
  groupId   String
  userId    String
  role      GroupRole  @default(MEMBER)
  createdAt DateTime   @default(now())

  group     FeedGroup  @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([groupId, userId])
  @@index([userId])
  @@map("feed_group_members")
}

enum MarketingAssetStatus {
  PENDING
  APPROVED
  REJECTED
}

model VerificationRequest {
  id             String             @id @default(dbgenerated("gen_random_uuid()"))
  userId         String
  user           User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  firstName      String
  lastName       String
  birthDate      DateTime
  idNumber       String
  idPhotoUrl     String
  selfiePhotoUrl String
  idVideoUrl     String?
  status         VerificationStatus @default(PENDING)
  note           String?
  reviewedAt     DateTime?
  reviewedById   String?
  reviewedBy     User?              @relation("VerificationReviewedBy", fields: [reviewedById], references: [id])
  createdAt      DateTime           @default(now())

  @@map("verification_requests")
  @@index([userId, status])
}

// Verification
enum VerificationStatus {
  PENDING
  APPROVED
  REJECTED
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_DATABASE_URL")
}

// User Types Enum
enum UserType {
  MEMBER
  ESCORT
  HOBBYHURE
  AGENCY
  CLUB
  STUDIO
}

enum Gender {
  MALE
  FEMALE
  NON_BINARY
  OTHER
}

enum OnboardingStatus {
  NOT_STARTED
  IN_PROGRESS
  COMPLETED
  SKIPPED
}

// Privacy & Notifications Enums
enum ProfileVisibility {
  PUBLIC
  VERIFIED
  PRIVATE
}

enum NotificationPreference {
  ALL
  IMPORTANT
  NONE
}

// Profile View selection for Escorts
enum ProfileView {
  STANDARD
  ALT1
  ALT2
  FULL_SIDE
}

// Membership & Add-ons
enum MembershipPlanKey {
  BASIS
  PLUS
  PREMIUM
  @@map("membership_plan_key")
}

enum AddonKey {
  ESCORT_OF_DAY
  ESCORT_OF_WEEK
  ESCORT_OF_MONTH
  CITY_BOOST
  PROFILE_ANALYTICS
  COUNTRY_BLOCK
  SEO
  @@map("addon_key")
}

enum MembershipStatus {
  ACTIVE
  CANCELED
  PAUSED
  EXPIRED
  @@map("membership_status")
}

enum BookingStatus {
  PENDING
  ACTIVE
  COMPLETED
  CANCELED
  @@map("booking_status")
}

// User Authentication Model
model User {
  id                String            @id @default(cuid())
  email             String            @unique
  password          String
  userType          UserType
  onboardingStatus  OnboardingStatus  @default(NOT_STARTED)
  isActive          Boolean           @default(true)
  isModerator       Boolean           @default(false)
  karma             Int               @default(0) // Reddit-style karma (upvotes - downvotes received)
  // Presence tracking
  lastSeenAt        DateTime?
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  // Relations
  profile           Profile?
  posts             Post[]
  stories           Story[]
  storyViews        StoryView[]
  comments          Comment[]        @relation("CommentAuthor")
  receivedComments  Comment[]        @relation("CommentTargetUser")
  sentMessages      Message[]         @relation("SentMessages")
  receivedMessages  Message[]         @relation("ReceivedMessages")
  following         Follow[]          @relation("Follower")
  followers         Follow[]          @relation("Following")
  likes             Like[]
  notifications     Notification[]
  billingCustomers  BillingCustomer[]
  verificationRequests VerificationRequest[]
  reviewedVerifications VerificationRequest[] @relation("VerificationReviewedBy")

  // Membership relations
  memberships       UserMembership[]
  addonBookings     UserAddonBooking[]
  addonStates       UserAddonState[]

  // Marketing orders
  marketingOrders   MarketingOrder[]

  // Forum relations
  forumThreads      ForumThread[]
  forumPosts        ForumPost[]
  threadSubscriptions ThreadSubscription[]
  postReports       ForumPostReport[] @relation("ReportReporter")

  // Blog posts authored by the user (internal blog)
  blogPosts         BlogPost[]

  // Feedback submitted by the user
  feedbacks         Feedback[]

  // Feed groups (legacy)
  feedGroupsOwned   FeedGroup[]
  feedGroupMemberships FeedGroupMember[]

  // Communities (Reddit-style)
  communitiesCreated    Community[]       @relation("CommunityCreator")
  communityMemberships  CommunityMember[]
  communityPosts        CommunityPost[]
  communityComments     CommunityComment[]
  communityVotes        Vote[]
  pollVotes             PollVote[]
  savedPosts            SavedPost[]
  communityBansReceived CommunityBan[]    @relation("BannedUser")
  communityBansIssued   CommunityBan[]    @relation("BanIssuedBy")
  modLogActions         CommunityModLog[] @relation("ModLogModerator")
  modLogTargets         CommunityModLog[] @relation("ModLogTarget")
  communityReportsFiled CommunityReport[] @relation("CommunityReporter")
  communityReportsResolved CommunityReport[] @relation("ReportResolver")

  // Gamification
  gamificationProfile GamificationProfile?
  gamificationEvents  GamificationEvent[]
  userBadges          UserBadge[]
  userPerks           UserPerk[]

  // Matching
  matchActionsMade     MemberMatchAction[] @relation("MemberMatchMember")
  matchActionsReceived MemberMatchAction[] @relation("MemberMatchEscort")

  // Dates (reconciled)
  dateRequestsAsEscort DateRequest[]      @relation("DateEscort")
  dateRequestsAsMember DateRequest[]      @relation("DateMember")

  // Profile visitors
  profileVisitsReceived ProfileVisit[] @relation("ProfileVisits")
  profileVisitsMade     ProfileVisit[] @relation("Visitor")

  // Profile analytics relations
  analyticsEventsAsTarget  ProfileAnalyticsEvent[] @relation("ProfileAnalyticsTarget")
  analyticsEventsAsVisitor ProfileAnalyticsEvent[] @relation("ProfileAnalyticsVisitor")

  // Jobs posted by this user (AGENCY/CLUB/STUDIO only)
  jobsPosted        Job[]
  // Rentals posted by this user (AGENCY/CLUB/STUDIO only)
  rentalsPosted     Rental[]

  // Review tickets relations
  reviewTicketsTarget   ReviewTicket[] @relation("TicketTargetUser")
  reviewTicketsIssued   ReviewTicket[] @relation("TicketIssuedBy")
  reviewTicketsRedeemed ReviewTicket[] @relation("TicketRedeemedBy")

  // Auth: password reset tokens
  passwordResetTokens  PasswordResetToken[]

  @@map("users")
}

// Track who visited whose profile
model ProfileVisit {
  id             String   @id @default(cuid())
  profileUserId  String
  visitorId      String?
  profileUser    User     @relation("ProfileVisits", fields: [profileUserId], references: [id], onDelete: Cascade)
  visitor        User?    @relation("Visitor", fields: [visitorId], references: [id], onDelete: SetNull)
  visitedAt      DateTime @default(now())

  @@index([profileUserId, visitedAt])
  @@index([visitorId, visitedAt])
  @@map("profile_visits")
}

model PasswordResetToken {
  id         String   @id @default(cuid())
  userId     String   @map("user_id")
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  tokenHash  String   @unique @map("token_hash")
  expiresAt  DateTime @map("expires_at")
  usedAt     DateTime? @map("used_at")
  createdAt  DateTime @default(now()) @map("created_at")

  @@index([userId, expiresAt])
  @@map("password_reset_tokens")
}

// Reconcile existing DB structures for Date Requests (Option C)
enum DateRequestStatus {
  PENDING
  ACCEPTED
  DECLINED
  CANCELED
  @@map("date_request_status")
}

model DateRequest {
  id               String             @id
  escortId         String             @map("escort_id")
  memberId         String             @map("member_id")
  startsAt         DateTime           @map("starts_at")
  endsAt           DateTime           @map("ends_at")
  durationMinutes  Int?               @map("duration_minutes")
  priceCents       Int?               @map("price_cents")
  currency         String?
  extras           Json?
  placeKey         String?            @map("place_key")
  placeLabel       String?            @map("place_label")
  outfitKey        String?            @map("outfit_key")
  outfitLabel      String?            @map("outfit_label")
  city             String?
  location         String?
  lat              Float?
  lng              Float?
  placeId          String?            @map("place_id")
  note             String?
  status           DateRequestStatus  @default(PENDING)
  createdAt        DateTime?          @default(now()) @map("created_at")

  // Relations
  escort           User               @relation("DateEscort", fields: [escortId], references: [id], onDelete: Cascade)
  member           User               @relation("DateMember", fields: [memberId], references: [id], onDelete: Cascade)

  @@index([escortId, status, startsAt], map: "idx_date_requests_escort")
  @@index([memberId, status, startsAt], map: "idx_date_requests_member")
  @@map("date_requests")
}

// Profile Model with different fields based on UserType
model Profile {
  id          String    @id @default(cuid())
  userId      String    @unique
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Common fields
  displayName String?
  bio         String?
  avatar      String?
  location    String?
  
  // Member specific fields
  age         Int?
  gender      Gender?
  preferences String?   // JSON string for member preferences
  
  // Escort specific fields
  slogan      String?
  nationality String?
  languages   String?   // JSON array of languages
  
  // Appearance fields (Escort)
  height      String?
  weight      String?
  bodyType    String?
  hairColor   String?
  eyeColor    String?
  // Extended appearance (Escort, step-2)
  hairLength   String?
  breastType   String?
  breastSize   String?
  intimateArea String?
  piercings    String?   // JSON array of strings
  tattoos      String?   // JSON array of strings
  clothingStyle String?
  clothingSize String?
  shoeSize     String?
  
  // Description (Escort)
  description String?
  services    String?   // JSON array of services
  
  // Gallery (Escort)
  gallery     String?   // JSON array of image URLs
  media       String?   // JSON array of media objects (images/videos)
  
  // Location details (Escort/Agency/Club/Studio)
  address     String?
  city        String?
  state       String?   // Kanton (CH) / Bundesland (DE/AT) — administrative_area_level_1
  country     String?
  zipCode     String?
  
  // Privacy & Notifications
  visibility             ProfileVisibility       @default(PUBLIC)
  notificationPreference NotificationPreference  @default(ALL)
  profileView            ProfileView             @default(STANDARD)
  
  // Structured geolocation fields
  latitude    Float?
  longitude   Float?
  locationPlaceId   String?
  locationFormatted String?
  
  // Contact information
  phone       String?
  website     String?
  socialMedia String?   // JSON object with social media links
  openingHours String?  // JSON object with weekly opening hours
  
  // Agency/Club/Studio specific
  companyName String?
  businessType String?
  established DateTime?
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@map("profiles")
  @@index([latitude, longitude])
  @@index([state])
}

// Posts Model
model Post {
  id        String   @id @default(cuid())
  content   String
  images    String?  // JSON array of image URLs
  authorId  String
  author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  // Optional group association for posts inside user-created groups
  groupId   String?
  group     FeedGroup? @relation(fields: [groupId], references: [id], onDelete: Cascade)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  likes     Like[]
  comments  Comment[]

  @@map("posts")
}

// Stories Model (only for non-Member users)
model Story {
  id        String   @id @default(cuid())
  content   String
  image     String?  // Single image URL
  video     String?  // Video URL
  authorId  String
  author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  expiresAt DateTime // Stories expire after 24 hours
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  
  views     StoryView[]

  @@map("stories")
}

model StoryView {
  id      String @id @default(cuid())
  storyId String
  userId  String
  story   Story  @relation(fields: [storyId], references: [id], onDelete: Cascade)
  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  viewedAt DateTime @default(now())

  @@unique([storyId, userId])
  @@map("story_views")
}

// Comments Model
model Comment {
  id        String   @id @default(cuid())
  content   String
  // Comment can target either a Post or a User (profile)
  postId    String?
  post      Post?    @relation(fields: [postId], references: [id], onDelete: Cascade)
  targetUserId String?
  targetUser   User?   @relation("CommentTargetUser", fields: [targetUserId], references: [id], onDelete: Cascade)
  // Author of the comment
  authorId  String
  author    User     @relation("CommentAuthor", fields: [authorId], references: [id], onDelete: Cascade)
  // Optional rating 1-5
  rating    Int?
  // Verified review via physical ticket
  verifiedByTicket Boolean @default(false)
  reviewTicketId   String?
  reviewTicket     ReviewTicket? @relation(fields: [reviewTicketId], references: [id], onDelete: SetNull)
  // Threaded replies
  parentId  String?
  parent    Comment? @relation("CommentToReplies", fields: [parentId], references: [id], onDelete: Cascade)
  children  Comment[] @relation("CommentToReplies")
  // Moderation & visibility
  isVisible         Boolean  @default(true)
  hiddenByOwner     Boolean  @default(false)
  deletionRequested Boolean  @default(false)
  deletionRequestMessage String?
  editRequested     Boolean  @default(false)
  editRequestMessage String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("comments")
  @@index([postId, parentId])
  @@index([targetUserId])
}

// Physical review ticket that an ESCORT can generate and hand to a MEMBER
model ReviewTicket {
  id            String   @id @default(cuid())
  code          String   @unique
  targetUserId  String
  targetUser    User     @relation("TicketTargetUser", fields: [targetUserId], references: [id], onDelete: Cascade)
  issuedById    String
  issuedBy      User     @relation("TicketIssuedBy", fields: [issuedById], references: [id], onDelete: Cascade)
  redeemedById  String?
  redeemedBy    User?    @relation("TicketRedeemedBy", fields: [redeemedById], references: [id], onDelete: SetNull)
  redeemedAt    DateTime?
  expiresAt     DateTime?
  maxUses       Int      @default(1)
  usedCount     Int      @default(0)
  createdAt     DateTime @default(now())

  // Back relation to comments created via this ticket
  comments      Comment[]

  @@index([targetUserId])
  @@index([issuedById])
  @@index([redeemedById])
  @@map("review_tickets")
}

// Messages Model
model Message {
  id         String   @id @default(cuid())
  content    String
  senderId   String
  receiverId String
  sender     User     @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)
  receiver   User     @relation("ReceivedMessages", fields: [receiverId], references: [id], onDelete: Cascade)
  isRead     Boolean  @default(false)
  createdAt  DateTime @default(now())

  @@map("messages")
}

// Follow Model
model Follow {
  id          String @id @default(cuid())
  followerId  String
  followingId String
  follower    User   @relation("Follower", fields: [followerId], references: [id], onDelete: Cascade)
  following   User   @relation("Following", fields: [followingId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())

  @@unique([followerId, followingId])
  @@map("follows")
}

// Likes Model
model Like {
  id     String @id @default(cuid())
  userId String
  postId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([userId, postId])
  @@map("likes")
}

// Notifications Model
model Notification {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  type      String   // "follow", "like", "comment", "message"
  title     String
  message   String
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())

  @@map("notifications")
}

// Billing Enums
enum BillingProvider {
  STRIPE
  PADDLE
  LEMONSQUEEZY
}

enum SubscriptionStatus {
  ACTIVE
  TRIALING
  PAST_DUE
  CANCELED
  INCOMPLETE
  UNPAID
}

// Billing Models
model BillingCustomer {
  id                   String           @id @default(cuid())
  userId               String
  user                 User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  provider             BillingProvider
  providerCustomerId   String
  defaultPaymentMethodId String?        @unique
  defaultPaymentMethod  PaymentMethod?  @relation("DefaultPaymentMethodOnCustomer", fields: [defaultPaymentMethodId], references: [id])
  createdAt            DateTime         @default(now())
  updatedAt            DateTime         @updatedAt

  // Relations
  paymentMethods       PaymentMethod[] @relation("CustomerPaymentMethods")
  subscriptions        Subscription[]
  invoices             Invoice[]

  @@unique([userId, provider])
  @@unique([provider, providerCustomerId])
  @@map("billing_customers")
}

model PaymentMethod {
  id                      String          @id @default(cuid())
  billingCustomerId       String
  billingCustomer         BillingCustomer @relation("CustomerPaymentMethods", fields: [billingCustomerId], references: [id], onDelete: Cascade)
  providerPaymentMethodId String
  brand                   String
  last4                   String
  expMonth                Int
  expYear                 Int
  isDefault               Boolean         @default(false)
  createdAt               DateTime        @default(now())
  // Back relation for the customer's default payment method
  defaultForCustomer      BillingCustomer? @relation("DefaultPaymentMethodOnCustomer")

  @@unique([billingCustomerId, providerPaymentMethodId])
  @@map("billing_payment_methods")
}

model Subscription {
  id                     String           @id @default(cuid())
  billingCustomerId      String
  billingCustomer        BillingCustomer  @relation(fields: [billingCustomerId], references: [id], onDelete: Cascade)
  providerSubscriptionId String
  status                 SubscriptionStatus
  planName               String?
  priceId                String?
  amount                 Int?
  currency               String?
  currentPeriodStart     DateTime?
  currentPeriodEnd       DateTime?
  cancelAt               DateTime?
  cancelAtPeriodEnd      Boolean?         @default(false)
  endedAt                DateTime?
  trialStart             DateTime?
  trialEnd               DateTime?
  createdAt              DateTime         @default(now())
  updatedAt              DateTime         @updatedAt

  // Relations
  invoices               Invoice[]

  @@unique([providerSubscriptionId])
  @@map("billing_subscriptions")
}

model Invoice {
  id                 String           @id @default(cuid())
  billingCustomerId  String
  billingCustomer    BillingCustomer  @relation(fields: [billingCustomerId], references: [id], onDelete: Cascade)
  subscriptionId     String?
  subscription       Subscription?    @relation(fields: [subscriptionId], references: [id])
  providerInvoiceId  String
  amount             Int
  currency           String
  status             String
  hostedInvoiceUrl   String?
  pdf                String?
  issuedAt           DateTime
  paidAt             DateTime?
  createdAt          DateTime        @default(now())

  @@index([subscriptionId])
  @@unique([providerInvoiceId])
  @@map("billing_invoices")
}

// Admin-configured membership plans
model MembershipPlan {
  id          String            @id @default(cuid())
  key         MembershipPlanKey
  name        String
  description String?
  priceCents  Int               // price per month in cents
  active      Boolean           @default(true)
  features    String?           // JSON array of strings
  sortOrder   Int               @default(0)
  userType    UserType?         // which account type this plan is for (null = legacy/fallback)
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  // Relations
  userMemberships UserMembership[]

  @@unique([key, userType])
  @@map("membership_plans")
}

// Admin-configured add-ons (container)
model Addon {
  id          String   @id @default(cuid())
  key         AddonKey @unique
  name        String
  description String?
  active      Boolean  @default(true)
  sortOrder   Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  options     AddonOption[]

  @@map("addons")
}

// Specific purchasable options for an addon (duration & price)
model AddonOption {
  id           String   @id @default(cuid())
  addonId      String
  addon        Addon    @relation(fields: [addonId], references: [id], onDelete: Cascade)
  durationDays Int
  priceCents   Int
  active       Boolean  @default(true)
  sortOrder    Int      @default(0)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  bookings     UserAddonBooking[]

  @@unique([addonId, durationDays])
  @@map("addon_options")
}

// A user's current or historical membership
model UserMembership {
  id          String           @id @default(cuid())
  userId      String
  user        User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  planId      String
  plan        MembershipPlan   @relation(fields: [planId], references: [id], onDelete: Restrict)
  status      MembershipStatus @default(ACTIVE)
  startedAt   DateTime         @default(now())
  endedAt     DateTime?
  cancelAt    DateTime?
  note        String?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  @@index([userId, status])
  @@map("user_memberships")
}

// Booked add-on instances per user
model UserAddonBooking {
  id            String        @id @default(cuid())
  userId        String
  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  addonOptionId String
  addonOption   AddonOption   @relation(fields: [addonOptionId], references: [id], onDelete: Restrict)
  status        BookingStatus @default(PENDING)
  startsAt      DateTime
  endsAt        DateTime
  note          String?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  @@index([userId, status])
  @@map("user_addon_bookings")
}

// Per-user toggle/state for add-ons (non-booking based)
model UserAddonState {
  id       String   @id @default(cuid())
  userId   String
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  key      AddonKey
  enabled  Boolean  @default(false)
  settings String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, key])
  @@index([userId, key])
  @@map("user_addon_states")
}

// General app settings (admin-editable key-value store)
model AppSetting {
  key       String   @id
  value     String   // JSON or plain text
  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())

  @@map("app_settings")
}

// Marketing / Advertising
enum MarketingPlacementKey {
  HOME_TOP
  HOME_MID
  HOME_BOTTOM
  HOME_BANNER
  HOME_TILE
  RESULTS_TOP
  SIDEBAR
  SPONSORED_POST
}

enum MarketingOrderStatus {
  DRAFT
  SUBMITTED
  APPROVED
  REJECTED
  ACTIVE
  COMPLETED
  CANCELED
}

// Blog categories
enum BlogCategory {
  AKTUELLES
  INTERESSANT_HEISSES
  VON_USER_FUER_USER
}

model MarketingOrder {
  id          String                @id @default(cuid())
  userId      String
  user        User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  status      MarketingOrderStatus  @default(DRAFT)
  currency    String                @default("EUR")
  totalCents  Int                   @default(0)
  note        String?
  createdAt   DateTime              @default(now())
  updatedAt   DateTime              @updatedAt

  items       MarketingOrderItem[]

  @@index([userId, status])
  @@map("marketing_orders")
}

model MarketingOrderItem {
  id            String               @id @default(cuid())
  orderId       String
  order         MarketingOrder       @relation(fields: [orderId], references: [id], onDelete: Cascade)
  placementKey  MarketingPlacementKey
  durationDays  Int
  priceCents    Int
  createdAt     DateTime             @default(now())

  assets        MarketingAsset[]

  @@index([orderId, placementKey])
  @@map("marketing_order_items")
}

model MarketingAsset {
  id           String              @id @default(cuid())
  orderItemId  String
  orderItem    MarketingOrderItem  @relation(fields: [orderItemId], references: [id], onDelete: Cascade)
  url          String
  targetUrl    String?
  mimeType     String?
  width        Int?
  height       Int?
  status       MarketingAssetStatus @default(PENDING)
  reviewNote   String?
  reviewedAt   DateTime?
  createdAt    DateTime            @default(now())

  @@index([orderItemId])
  @@map("marketing_assets")
}

// Blog Posts (internal blog)
model BlogPost {
  id          String   @id @default(cuid())
  title       String
  slug        String   @unique
  excerpt     String?
  content     String?
  coverImage  String?
  published   Boolean  @default(false)
  blocked     Boolean  @default(false)
  publishedAt DateTime?
  category    BlogCategory @default(AKTUELLES)
  authorId    String
  author      User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([published, publishedAt])
  @@index([authorId])
  @@map("blog_posts")
}

// Forum Models

model ForumCategory {
  id          String   @id @default(cuid())
  name        String
  description String?
  sortOrder   Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  forums      Forum[]

  @@map("forum_categories")
}

model Forum {
  id          String   @id @default(cuid())
  categoryId  String
  category    ForumCategory @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  parentId    String?
  parent      Forum?   @relation("Subforums", fields: [parentId], references: [id])
  children    Forum[]  @relation("Subforums")
  name        String
  slug        String   @unique
  description String?
  icon        String?
  image       String?
  sortOrder   Int      @default(0)
  isLocked    Boolean  @default(false)
  isHidden    Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  threads     ForumThread[]

  @@index([categoryId, parentId])
  @@map("forums")
}

model ForumThread {
  id         String  @id @default(cuid())
  forumId    String
  forum      Forum   @relation(fields: [forumId], references: [id], onDelete: Cascade)
  authorId   String
  author     User    @relation(fields: [authorId], references: [id], onDelete: Cascade)
  title      String
  isPinned   Boolean @default(false)
  isClosed   Boolean @default(false)
  views      Int     @default(0)
  lastPostAt DateTime @default(now())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  posts      ForumPost[]
  subscriptions ThreadSubscription[]

  @@index([forumId, isPinned, lastPostAt])
  @@map("forum_threads")
}

model ForumPost {
  id        String   @id @default(cuid())
  threadId  String
  thread    ForumThread @relation(fields: [threadId], references: [id], onDelete: Cascade)
  authorId  String
  author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  content   String
  parentId  String?
  parent    ForumPost? @relation("ForumPostReplies", fields: [parentId], references: [id], onDelete: Cascade)
  children  ForumPost[] @relation("ForumPostReplies")
  editedAt  DateTime?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  reports   ForumPostReport[]

  @@index([threadId, parentId, createdAt])
  @@map("forum_posts")
}

model ThreadSubscription {
  id        String @id @default(cuid())
  userId    String
  user      User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  threadId  String
  thread    ForumThread @relation(fields: [threadId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([userId, threadId])
  @@map("thread_subscriptions")
}

model ForumPostReport {
  id         String @id @default(cuid())
  postId     String
  post       ForumPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  reporterId String
  reporter   User @relation("ReportReporter", fields: [reporterId], references: [id], onDelete: Cascade)
  reason     String?
  status     String @default("OPEN")
  createdAt  DateTime @default(now())
  resolvedAt DateTime?

  @@index([postId, status])
  @@map("forum_post_reports")
}

// Profile analytics event log
model ProfileAnalyticsEvent {
  id             String   @id @default(cuid())
  profileUserId  String
  profileUser    User     @relation("ProfileAnalyticsTarget", fields: [profileUserId], references: [id], onDelete: Cascade)
  visitorId      String?
  visitor        User?    @relation("ProfileAnalyticsVisitor", fields: [visitorId], references: [id], onDelete: SetNull)
  sessionId      String
  type           String   // view_start, view_end, click
  path           String?
  referrer       String?
  country        String?
  userAgent      String?
  browser        String?
  os             String?
  device         String?
  durationMs     Int?
  meta           String?  // JSON payload for flexible fields (e.g., clicks)
  createdAt      DateTime @default(now())

  @@index([profileUserId, createdAt])
  @@index([visitorId, createdAt])
  @@index([sessionId, type])
  @@map("profile_analytics_events")
}

// Gamification

enum GamificationEventType {
  DAILY_LOGIN
  FORUM_POST
  FORUM_REPLY
  FORUM_THREAD
  FORUM_THREAD_CLOSE
  FORUM_THREAD_OPEN
  FEED_POST
  BLOG_POST
  BLOG_PUBLISH
  BLOG_UPDATE_MAJOR
  COMMENT_VERIFIED
  REGULAR_USE
  // Community (Reddit) events
  COMMUNITY_CREATE
  COMMUNITY_POST
  COMMUNITY_COMMENT
  COMMUNITY_VOTE
  COMMUNITY_RECEIVE_UPVOTE
  COMMUNITY_MOD_ACTION
}

model GamificationProfile {
  id             String   @id @default(cuid())
  userId         String   @unique
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  points         Int      @default(0)
  level          Int      @default(1)
  streakDays     Int      @default(0)
  lastLoginAt    DateTime?
  totalLogins    Int      @default(0)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@map("gamification_profiles")
}

model GamificationEvent {
  id          String                 @id @default(cuid())
  userId      String
  user        User                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  type        GamificationEventType
  points      Int                    @default(0)
  metadata    String?
  createdAt   DateTime               @default(now())

  @@index([userId, type, createdAt])
  @@map("gamification_events")
}

model Badge {
  id           String   @id @default(cuid())
  key          String   @unique
  name         String
  description  String?
  icon         String?
  pointsReward Int      @default(0)
  active       Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  userBadges   UserBadge[]

  @@map("badges")
}

model UserBadge {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  badgeId   String
  badge     Badge    @relation(fields: [badgeId], references: [id], onDelete: Cascade)
  awardedAt DateTime @default(now())

  @@unique([userId, badgeId])
  @@index([badgeId])
  @@map("user_badges")
}

model Perk {
  id           String   @id @default(cuid())
  key          String   @unique
  name         String
  description  String?
  thresholdPts Int      @default(0)
  active       Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  userPerks    UserPerk[]

  @@map("perks")
}

model UserPerk {
  id         String   @id @default(cuid())
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  perkId     String
  perk       Perk     @relation(fields: [perkId], references: [id], onDelete: Cascade)
  unlockedAt DateTime @default(now())
  claimedAt  DateTime?

  @@unique([userId, perkId])
  @@index([perkId])
  @@map("user_perks")
}

// Matching system: store member swipe actions on escorts
enum MatchActionType {
  LIKE
  PASS
}

model MemberMatchAction {
  id        String          @id @default(cuid())
  memberId  String
  member    User            @relation("MemberMatchMember", fields: [memberId], references: [id], onDelete: Cascade)
  escortId  String
  escort    User            @relation("MemberMatchEscort", fields: [escortId], references: [id], onDelete: Cascade)
  action    MatchActionType
  createdAt DateTime        @default(now())

  @@unique([memberId, escortId])
  @@index([memberId])
  @@index([escortId])
  @@map("member_match_actions")
}

// User Feedback
enum FeedbackStatus {
  OPEN
  IN_REVIEW
  RESOLVED
}

// Reason for user feedback/contact
enum FeedbackReason {
  REPORT_AD       // Ich möchte eine Anzeige melden
  BUG             // Etwas funktioniert nicht
  PRAISE          // Ich möchte Lob und Kritik hinterlassen
  ADVERTISING     // Ich möchte Werbung auf TheGND schalten
  CUSTOMER_SERVICE // Ich suche den Kontakt zu einem Kundenbetreuer
  OTHER           // Etwas anderes
}

model Feedback {
  id        String         @id @default(cuid())
  userId    String?
  user      User?          @relation(fields: [userId], references: [id], onDelete: SetNull)
  email     String?
  message   String
  reason    FeedbackReason?
  customTitle String?
  contact   String?
  status    FeedbackStatus @default(OPEN)
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt

  @@index([status, createdAt])
  @@index([reason])
  @@map("feedback")
}

// ─── SEO Management ────────────────────────────────────────────────────────

// Per-page SEO overrides (admin-managed)
model SeoPageOverride {
  id              String   @id @default(cuid())
  urlPath         String   @unique        // e.g. "/escorts", "/blog/my-post"
  metaTitle       String?
  metaDescription String?
  metaKeywords    String?
  ogTitle         String?
  ogDescription   String?
  ogImageUrl      String?
  robots          String?                 // e.g. "index,follow" or "noindex,nofollow"
  canonicalUrl    String?
  priority        Float    @default(0.6)  // sitemap priority
  changeFrequency String   @default("daily") // sitemap changeFrequency
  enabled         Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([urlPath])
  @@map("seo_page_overrides")
}

// Redirect rules (admin-managed)
model SeoRedirect {
  id         String   @id @default(cuid())
  sourcePath String   @unique           // e.g. "/old-page"
  targetUrl  String                     // e.g. "/new-page" or "https://example.com"
  statusCode Int      @default(301)     // 301 or 302
  enabled    Boolean  @default(true)
  hitCount   Int      @default(0)
  lastHitAt  DateTime?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([sourcePath])
  @@index([enabled])
  @@map("seo_redirects")
}

// JSON-LD structured data snippets (admin-managed)
model SeoStructuredData {
  id             String   @id @default(cuid())
  name           String                   // display name, e.g. "Organization"
  schemaType     String                   // e.g. "Organization", "LocalBusiness", "FAQPage"
  urlPattern     String                   // where it's rendered, e.g. "/" or "/escorts/*"
  jsonLdTemplate String                   // JSON string with the schema.org markup
  enabled        Boolean  @default(true)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@index([urlPattern])
  @@index([enabled])
  @@map("seo_structured_data")
}
